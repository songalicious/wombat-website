<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ðŸ§©</title>
  <style>
    body {
      background: black;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      margin: 0;
      padding: 20px;
      color: white;
      font-family: Arial, sans-serif;
    }
    canvas {
      background: black;
      display: block;
      margin-right: 20px;
    }
    #sidebar {
      width: 200px;
    }
  </style>
</head>
<body>
  <canvas id="tetris"></canvas>
  <div id="sidebar">
    <h2>Time</h2>
    <div id="time">0s</div>
  </div>

  <script>
    const canvas = document.getElementById("tetris");
    const context = canvas.getContext("2d");
    const cellSize = 30;
    const cols = 10, rows = 20;
    canvas.width = cols * cellSize;
    canvas.height = rows * cellSize;

    const shapes = [
      [[1,1,1,1]],
      [[1,1],[1,1]],
      [[0,1,0],[1,1,1]],
      [[1,0,0],[1,1,1]],
      [[0,0,1],[1,1,1]],
      [[1,1,0],[0,1,1]],
      [[0,1,1],[1,1,0]],
    ];

    function newPiece() {
      const shape = shapes[Math.floor(Math.random()*shapes.length)];
      const gray = 220 + Math.floor(Math.random()*10 - 5);
      const color = `rgb(${Math.min(255,gray)},${Math.min(255,gray)},${Math.min(255,gray)})`;
      return {shape, x: Math.floor(cols/2 - shape[0].length/2), y: 0, color};
    }

    function rotate(shape) {
      return shape[0].map((_,i) => shape.map(row => row[i])).reverse();
    }

    function validPosition(piece, adjX=0, adjY=0) {
      for (let y=0; y<piece.shape.length; y++) {
        for (let x=0; x<piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            const newX = piece.x + x + adjX;
            const newY = piece.y + y + adjY;
            if (newX < 0 || newX >= cols || newY >= rows || (newY >= 0 && grid[newY][newX])) {
              return false;
            }
          }
        }
      }
      return true;
    }

    function freeze(piece) {
      for (let y=0; y<piece.shape.length; y++) {
        for (let x=0; x<piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            grid[piece.y+y][piece.x+x] = piece.color;
          }
        }
      }
    }

    function clearLines() {
      for (let y=rows-1; y>=0; y--) {
        if (grid[y].every(cell => cell)) {
          grid.splice(y,1);
          grid.unshift(Array(cols).fill(0));
          y++;
        }
      }
    }

    function drawGrid() {
      for (let y=0; y<rows; y++) {
        for (let x=0; x<cols; x++) {
          if (grid[y][x]) {
            context.fillStyle = grid[y][x];
            context.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
          }
        }
      }
    }

    function drawPiece(piece) {
      for (let y=0; y<piece.shape.length; y++) {
        for (let x=0; x<piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            context.fillStyle = piece.color;
            context.fillRect((piece.x+x)*cellSize, (piece.y+y)*cellSize, cellSize, cellSize);
          }
        }
      }
    }

    let grid = Array.from({length: rows}, () => Array(cols).fill(0));
    let currentPiece = newPiece();
    let dropCounter = 0;
    let dropInterval = 500;
    let lastTime = 0;
    let startTime = Date.now();
    let frozenTime = null;
    let gameOver = false;

    function update(time=0) {
      const deltaTime = time - lastTime;
      lastTime = time;
      if (!gameOver) {
        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
          dropCounter = 0;
          if (validPosition(currentPiece,0,1)) {
            currentPiece.y++;
          } else {
            freeze(currentPiece);
            clearLines();
            currentPiece = newPiece();
            if (!validPosition(currentPiece)) {
              gameOver = true;
              frozenTime = Math.floor((Date.now() - startTime)/1000);
            }
          }
        }
      }
      context.clearRect(0,0,canvas.width,canvas.height);
      drawGrid();
      if (!gameOver) drawPiece(currentPiece);

      const elapsed = gameOver ? frozenTime : Math.floor((Date.now() - startTime)/1000);
      document.getElementById("time").textContent = elapsed + "s";

      requestAnimationFrame(update);
    }

    document.addEventListener("keydown", event => {
      if (gameOver) return;
      if (event.key === "ArrowLeft" && validPosition(currentPiece,-1,0)) {
        currentPiece.x--;
      } else if (event.key === "ArrowRight" && validPosition(currentPiece,1,0)) {
        currentPiece.x++;
      } else if (event.key === "ArrowDown" && validPosition(currentPiece,0,1)) {
        currentPiece.y++;
      } else if (event.key === "ArrowUp") {
        const rotated = {shape: rotate(currentPiece.shape), x: currentPiece.x, y: currentPiece.y, color: currentPiece.color};
        if (validPosition(rotated)) currentPiece = rotated;
      }
    });

    update();
  </script>
</body>
</html>
